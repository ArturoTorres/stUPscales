mprob=0.1, mdist=20,
lower.bounds=c(2.5,200),
upper.bounds= c(4.5,1000))
remove.packages("stUPscales")
detach("package:stUPscales", unload = TRUE)
install.packages("~/Documents/02_working/3-Production/03_II-Year/05_models/06_uncertainty/Uncert-opt-comp/stUPscales_1.0.2.tar.gz", repos=NULL, type="source")
install.packages("msm")
install.packages("~/Documents/02_working/3-Production/03_II-Year/05_models/06_uncertainty/Uncert-opt-comp/stUPscales_1.0.2.tar.gz", repos=NULL, type="source")
library(EmiStatR) # version 1.2.0.4
library(stUPscales) # version 1.0.2
settings <-  setup(id       = "MC_calibra1",
nsim     = 20,
seed     = 123,
mcCores  = 40,
ts.input = P1,
rng      = rng <- list(
qs   = c(pdf = "dis", min = 140, max = 170, nsample = 4),          #[l/PE/d]
CODs = 104,                                                        # [g/PE/d]
NH4s = 3.5,                                                        # [g/PE/d]
qf   = c(pdf = "dis", min = 0.02, max = 0.05, nsample = 4),        # [l/s/ha]
CODf = 0,                                                          # [g/PE/d]
NH4f = 0,                                                          # [g/PE/d]
CODr = 71,                                                         # [mg/l]
NH4r = 1,                                                          # [mg/l]
# tf   = 20,                                                       # [min]
nameCSO = "E1",                                                    # [-]
id      = 1,                                                       # [-]
ns      = "FBH Goesdorf",                                          # [-]
nm      = "Goesdorf",                                              # [-]
nc      = "Obersauer",                                             # [-]
numc    = 1,                                                       # [-]
use     = "R/I",                                                   # [-]
Atotal  =  36,                                                     # [ha]
Aimp    =  25.2,                                                   # 36*.7 [ha]
Cimp    = c(pdf = "tnor", mu = 0.85, sigma = 0.01, lower = 0.65, upper = 0.95),  # 0.85 [-]
Cper    = c(pdf = "tnor", mu = 0.60, sigma = 0.01, lower = 0.30, upper = 0.70),  # 0.60 [-]
tfS     = c(pdf = "dis", min = 1, max = 3, nsample = 3),           # [time steps]
pe      = c(pdf = "dis", min = 550, max = 700, nsample = 4),       # [PE]
Qd      = 5,                                                       # [l/s]
Dd      = 0.150,                                                   # [m]
Cd      = 0.18,                                                    # [-]
V       = 190,                                                     # [m3]
lev.ini = c(pdf = "dis", min = .1, max = 3.5, nsample = 4),        # [m]
lev2vol = lev2vol                                                  # [m] - [m3]
),
ar.model  = ar.model <- list(
CODs    = 0.5,
NH4s    = 0.5,
CODr    = 0.7),
var.model = var.model <- list(
inp     = c("", ""), # c("CODs", "NH4s"), # c("", ""),
w       = c(0.04778205, 0.02079010),
A       = matrix(c(9.916452e-01, -8.755558e-05,
-0.003189094, 0.994553910), nrow=2, ncol=2),
C       = matrix(c(0.009126591, 0.002237936,
0.002237936, 0.001850941), nrow=2, ncol=2)),
folderOutput = paste(workingFolder,"/analysis-output",sep=""))
lev2vol <- list(lev = c(.06, 1.10, 1.30, 3.30), vol = c(0, 31, 45, 190))
workingFolder <- "~/Documents/02_working/3-Production/04_III-Year/05_models/01_EmiStatR/R/calibra_reproducible"
settings <-  setup(id       = "MC_calibra1",
nsim     = 20,
seed     = 123,
mcCores  = 40,
ts.input = P1,
rng      = rng <- list(
qs   = c(pdf = "dis", min = 140, max = 170, nsample = 4),          #[l/PE/d]
CODs = 104,                                                        # [g/PE/d]
NH4s = 3.5,                                                        # [g/PE/d]
qf   = c(pdf = "dis", min = 0.02, max = 0.05, nsample = 4),        # [l/s/ha]
CODf = 0,                                                          # [g/PE/d]
NH4f = 0,                                                          # [g/PE/d]
CODr = 71,                                                         # [mg/l]
NH4r = 1,                                                          # [mg/l]
# tf   = 20,                                                       # [min]
nameCSO = "E1",                                                    # [-]
id      = 1,                                                       # [-]
ns      = "FBH Goesdorf",                                          # [-]
nm      = "Goesdorf",                                              # [-]
nc      = "Obersauer",                                             # [-]
numc    = 1,                                                       # [-]
use     = "R/I",                                                   # [-]
Atotal  =  36,                                                     # [ha]
Aimp    =  25.2,                                                   # 36*.7 [ha]
Cimp    = c(pdf = "tnor", mu = 0.85, sigma = 0.01, lower = 0.65, upper = 0.95),  # 0.85 [-]
Cper    = c(pdf = "tnor", mu = 0.60, sigma = 0.01, lower = 0.30, upper = 0.70),  # 0.60 [-]
tfS     = c(pdf = "dis", min = 1, max = 3, nsample = 3),           # [time steps]
pe      = c(pdf = "dis", min = 550, max = 700, nsample = 4),       # [PE]
Qd      = 5,                                                       # [l/s]
Dd      = 0.150,                                                   # [m]
Cd      = 0.18,                                                    # [-]
V       = 190,                                                     # [m3]
lev.ini = c(pdf = "dis", min = .1, max = 3.5, nsample = 4),        # [m]
lev2vol = lev2vol                                                  # [m] - [m3]
),
ar.model  = ar.model <- list(
CODs    = 0.5,
NH4s    = 0.5,
CODr    = 0.7),
var.model = var.model <- list(
inp     = c("", ""), # c("CODs", "NH4s"), # c("", ""),
w       = c(0.04778205, 0.02079010),
A       = matrix(c(9.916452e-01, -8.755558e-05,
-0.003189094, 0.994553910), nrow=2, ncol=2),
C       = matrix(c(0.009126591, 0.002237936,
0.002237936, 0.001850941), nrow=2, ncol=2)),
folderOutput = paste(workingFolder,"/analysis-output",sep=""))
x = settings
id           <- slot(x, "id")
nsim         <- slot(x, "nsim")
seed         <- slot(x, "seed")
mcCores      <- slot(x, "mcCores")
ts.input     <- slot(x, "ts.input")
rng          <- slot(x, "rng")
ar.model     <- slot(x, "ar.model")
var.model    <- slot(x, "var.model")
folderOutput <- slot(x, "folderOutput")
par <- rng
set.seed(seed)
npar <- 0
indexVAR <- 0
l <- 1
ifelse(length(var.model[[1]]) > 0,
{
if(var.model[["inp"]][1] != "")
{for(k in 1:length(var.model[["inp"]])){
indexVAR[l] <- which(names(rng)==var.model[["inp"]][k])
l <- l+1
}
indexVAR
}else{indexVAR <- c(0,0)}
}, indexVAR <- c(0,0)
)
nsim.c6 <- 0
id.c6   <- 0
for (i in 1:length(rng)){
if(i == indexVAR[2] | class(rng[[i]][1])=="list"){next}
if(length(rng[[i]]) > 1 & rng[[i]][1] == "uni") {case <- 1}
if(length(rng[[i]]) > 1 & rng[[i]][1] == "nor" & any(names(rng)[[i]] == names(ar.model)) &
!any(names(rng)[[i]] == var.model[["inp"]])) {case <- 2}
if(length(rng[[i]]) > 1 & rng[[i]][1] == "nor" & !any(names(rng)[[i]] == names(ar.model))) {case <- 3}
if(length(rng[[i]]) == 1) {case <- 4}
if(length(rng[[i]]) > 1 & rng[[i]][1] == "nor" & any(names(rng)[[i]] == names(ar.model)) &
any(names(rng)[[i]] == var.model[["inp"]])) {case <- 5}
# discrete sampling
if(length(rng[[i]]) > 1 & rng[[i]][1] == "dis") {case <- 6}
# truncated normal distribution
# i <- 18
if(length(rng[[i]]) > 1 & rng[[i]][1] == "tnor") {case <- 7}
# sampling cases definition
switch(case,
# case 1: uniform sampling ---------------------------------------------------------------------------------------------------
{r <- matrix(NA, nrow=nsim, ncol = nrow(ts.input))
j <- 1
for(j in 1:nsim){
r[j,] <- runif(nrow(ts.input), min=as.numeric(rng[[i]]["min"]), max=as.numeric(rng[[i]]["max"]))
}
par[[i]] <- r
npar <- npar+1
},
# case 2: normal autocorrelated time series (AR1 model) ----------------------------------------------------------------------
{requireNamespace("lmom")
r <- matrix(NA, nrow=nsim, ncol = nrow(ts.input))
j <- 1
for(j in 1:nsim){
# r[j,] <- quanor(runif(nrow(ts.input)), c(as.numeric(rng[[i]]["mu"]), as.numeric(rng[[i]]["sigma"])))
y1 <- arima.sim(n = nrow(ts.input) , list(order=c(1,0,0), ar=ar.model[[names(rng)[[i]]]]))  # ar =.5
m1 <- mean(y1);    s1 <- sd(y1)
m2 <- as.numeric(rng[[i]]["mu"]); s2 <- as.numeric(rng[[i]]["sigma"])
y2 <- m2 +(y1-m1)*s2/s1
r[j,] <- y2
}
par[[i]] <- r
npar <- npar+1
},
# case 3: normal non-autocorrelated time series ----------------------------------------------------------------------------------
{requireNamespace("lmom")
r <- matrix(NA, nrow=nsim, ncol = 1)
# i <- 7
# j <- 1
for(j in 1:nsim){
r[j,1] <- quanor(runif(1), c(as.numeric(rng[[i]]["mu"]), as.numeric(rng[[i]]["sigma"])))
}
par[[i]] <- r
npar <- npar+1
},
# case 4: constant value ---------------------------------------------------------------------------------------------------------
{par[[i]] <- rng[[i]]
},
# # case 5: normal auto- and cross-correlated time series (var.model) --------------------------------------------------------------
# {
#   library(lmom)
#   library(mAr)
#   r <- matrix(NA, nrow=nsim, ncol = nrow(ts.input))
#
#   index <- 0
#   l <- 1
#   for(k in 1:length(var.model[["inp"]])){
#
#     for(j in 1:nsim){
#
#       y1 <- mAr.sim(w = var.model[["w"]], A = var.model[["A"]], C = var.model[["C"]], N = nrow(ts.input))
#
#       index[l] <- which(names(rng)==var.model[["inp"]][k])
#
#       r[j,] <- quanor(runif(nrow(ts.input)), c(as.numeric(rng[[index[l]]]["mu"]), as.numeric(rng[[index[l]]]["sigma"])))
#
#       m1 <- mean(y1[,l]); s1 <- sd(y1[,l])
#       m2 <- mean(r[j,]); s2 <- sd(r[j,])
#       y2 <- m2 +(y1[,l]-m1)*s2/s1
#
#       r[j,] <- y2
#     }
#     l <- l+1
#
#     par[[index[l-1]]] <- r
#     npar <- npar+1
#   }
# }
# case 5: normal auto- and cross-correlated time series (var.model), parallel code -------------------------------
{
var1 <- (matrix(NA, nrow=1, ncol = nrow(ts.input)) )
var2 <- (matrix(NA, nrow=1, ncol = nrow(ts.input)) )
obj1 <- 1:nsim
requireNamespace("parallel")
requireNamespace("doParallel")
requireNamespace("foreach")
cl <- makeCluster(mcCores, outfile="")
registerDoParallel(cl, cores=mcCores)
numCores <- detectCores()
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
rp <- foreach(obj1 = obj1, .packages = c("lmom", "mAr", "parallel", "doParallel", "foreach"), .export=c("obj1"),
.errorhandling = "pass", .verbose=TRUE, .combine = "rbind") %dopar% {
# j <- 1
j <- obj1
print(paste(j, ", ", mcCores, " of ", numCores, " cores for creating VAR model", sep=""))
y1 <- mAr.sim(w = var.model[["w"]], A = var.model[["A"]], C = var.model[["C"]], N = nrow(ts.input))
# code for only bivariate case
m1 <- mean(y1[,1]); s1 <- sd(y1[,1])
m2 <- as.numeric(rng[[indexVAR[1]]]["mu"]); s2 <- as.numeric(rng[[indexVAR[1]]]["sigma"])
y2 <- m2 +(y1[,1]-m1)*s2/s1
var1[1,] <- y2
m1 <- mean(y1[,2]); s1 <- sd(y1[,2])
m2 <- as.numeric(rng[[indexVAR[2]]]["mu"]); s2 <- as.numeric(rng[[indexVAR[2]]]["sigma"])
y2 <- t(as.data.frame(m2 +(y1[,2]-m1)*s2/s1))
var2[1,] <- y2
return(c(var1, var2))
}
stopCluster(cl)
# closeAllConnections()
# asignation only for bivariate case:
par[[indexVAR[1]]] <- rp[,1:nrow(ts.input)]
par[[indexVAR[2]]] <- rp[,(nrow(ts.input)+1):(nrow(ts.input)*2)]
npar <- npar+2
},
# case 6: discrete sampling ------------------------------------------------------------------
{id.c6    <- c(id.c6, i)
r <- seq(from = as.numeric(rng[[i]]["min"]), to = as.numeric(rng[[i]]["max"]),
length.out=as.numeric(rng[[i]]["nsample"]))
nsim.c6  <- c(nsim.c6, length(r))
par[[i]] <- r
npar <- npar+1
}
)
}
i <- 18
if(length(rng[[i]]) > 1 & rng[[i]][1] == "tnor") {case <- 7}
requireNamespace("msm")
i <- 18
j <- 1
runif(1)
?rtnorm
r <- matrix(NA, nrow=nsim, ncol = 1)
r[j,1] <- rtnorm(x=1, mean=c(as.numeric(rng[[i]]["mu"]), sd=as.numeric(rng[[i]]["sigma"])),
lower=c(as.numeric(rng[[i]]["lower"]), upper=c(as.numeric(rng[[i]]["upper"]))
}
par[[i]] <- r
npar <- npar+1
}
)
}
npars <- length(rng)
return(list(id = id, nsim=nsim, seed=seed, mcCores = mcCores, ts.input=ts.input, rng=rng, par=par,
ar.model=ar.model, var.model=var.model, folderOutput=folderOutput, nsim.c6 = nsim.c6,
id.c6 = id.c6))
}
)
r[j,1] <- rtnorm(x=1, mean=c(as.numeric(rng[[i]]["mu"])),
sd=as.numeric(rng[[i]]["sigma"]),
lower=c(as.numeric(rng[[i]]["lower"])),
upper=c(as.numeric(rng[[i]]["upper"])))
library(msm)
r[j,1] <- rtnorm(x=1, mean=c(as.numeric(rng[[i]]["mu"])),
sd=as.numeric(rng[[i]]["sigma"]),
lower=c(as.numeric(rng[[i]]["lower"])),
upper=c(as.numeric(rng[[i]]["upper"])))
r[j,1] <- rtnorm(n=1, mean=c(as.numeric(rng[[i]]["mu"])),
sd=as.numeric(rng[[i]]["sigma"]),
lower=c(as.numeric(rng[[i]]["lower"])),
upper=c(as.numeric(rng[[i]]["upper"])))
r
r <- matrix(NA, nrow=nsim, ncol = 1)
for(j in 1:nsim){
r[j,1] <- rtnorm(n=1, mean=c(as.numeric(rng[[i]]["mu"])),
sd=as.numeric(rng[[i]]["sigma"]),
lower=c(as.numeric(rng[[i]]["lower"])),
upper=c(as.numeric(rng[[i]]["upper"])))
}
r
c(as.numeric(rng[[i]]["lower"]))
rm(list=ls())
wcs = "http://webservices.isric.org/geoserver/wcs?"
l1 <- newXMLNode("WCS_GDAL")
library(XML)
wcs = "http://webservices.isric.org/geoserver/wcs?"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "orcdrc_m_sl1_250m", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
getwd()
system(paste(gdalinfo, xml.out))
library(rgdal)
system(paste(gdalinfo, xml.out))
install.packages("gdalUtils")
library(gdalUtils)
system(paste(gdalinfo, xml.out))
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste(gdalinfo, xml.out))
library(XML)
library(gdalUtils)
wcs = "http://webservices.isric.org/geoserver/wcs?"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "orcdrc_m_sl1_250m", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste(gdalinfo, xml.out))
library(rgdal)
system(paste(gdalinfo, xml.out))
sg.ftp <- "ftp://ftp.soilgrids.org/data/recent/"
filenames = getURL(sg.ftp, ftp.use.epsv = TRUE, dirlistonly = TRUE)
library(RCurl)
filenames = getURL(sg.ftp, ftp.use.epsv = TRUE, dirlistonly = TRUE)
filenames = strsplit(filenames, "\r*\n")[[1]]
filenames[1:5]
filenames[1:5]
wcs = "http://webservices.isric.org/geoserver/wcs?"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "AWCh1_M_sl2_250m.tif", parent=l1)
l1
xml.out = "AWCh1_M_sl2_250m.xml"
saveXML(l1, file=xml.out)
system(paste(gdalinfo, xml.out))
l1.l <- newXMLNode("CoverageName", "orcdrc_m_sl1_250m", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste(gdalinfo, xml.out))
sg.ftp <- "ftp://ftp.soilgrids.org/data/recent/"
filenames = getURL(sg.ftp, ftp.use.epsv = TRUE, dirlistonly = TRUE)
filenames = strsplit(filenames, "\r*\n")[[1]]
filenames[1:5]
ORC.name <- filenames[grep(filenames, pattern=glob2rx("ORCDRC_M_sl1_250m_ll.tif$"))]
ORC.name
filenames[1:5]
ORC.name <- filenames[grep(filenames, pattern=glob2rx("ACDWRB_M_ss_250m.tif$"))]
ORC.name
try(download.file(paste(sg.ftp, ORC.name, sep=""), ORC.name))
GDALinfo(ORC.name)
l1
ORC.name <- filenames[grep(filenames, pattern=glob2rx("orcdrc_m_sl1_250m.tif$"))]
ORC.name
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "ACDWRB_M_ss_250m.tif", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste(gdalinfo, xml.out))
paste(gdalinfo, xml.out)
xml.out = "ORCDRC_M_sl1.xml"
paste(gdalinfo, xml.out)
system(paste("gdalinfo", xml.out))
l1.l <- newXMLNode("CoverageName", "ACDWRB_M_ss_250m", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste("gdalinfo", xml.out))
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "ACDWRB_M_ss_250m", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste("gdalinfo", xml.out))
wcs = "http://webservices.isric.org/geoserver/wcs?"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "ACDWRB_M_ss_250m.tif", parent=l1)
l1
xml.out = "ORCDRC_M_sl1.xml"
saveXML(l1, file=xml.out)
system(paste("gdalinfo", xml.out))
wcs = "http://fast.openearth.eu/geoserver/ows?service=WCS&version=2.0.1&request=GetCapabilities"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "England_Study_Site_DonnaNook:DTM", parent=l1)
l1
xml.out = "England_Study_Site_DonnaNook:DTM.xml"
saveXML(l1, file = xml.out)
system(paste('gdalinfo', xml.out))
wcs = "http://fast.openearth.eu/geoserver/ows?service=WCS&version=2.0.1&request=GetCapabilities"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "FAST_NL_Study_Site_Paulina__PaulinaPolder_DTM_5m", parent=l1)
l1
xml.out = "FAST_NL_Study_Site_Paulina__PaulinaPolder_DTM_5m.xml"
saveXML(l1, file = xml.out)
system(paste('gdalinfo', xml.out))
wcs = "http://fast.openearth.eu/geoserver/ows?service=WCS&version=2.0.1&request=GetCapabilities"
l1 <- newXMLNode("WCS_GDAL")
l1.s <- newXMLNode("ServiceURL", wcs, parent=l1)
l1.l <- newXMLNode("CoverageName", "FAST_UK_Study_Site_Donna_Nook__Intertidal Elevation", parent=l1)
l1
xml.out = "FAST_UK_Study_Site_Donna_Nook__Intertidal Elevation.xml"
saveXML(l1, file = xml.out)
system(paste('gdalinfo', xml.out))
install.packages(c("rJava", "testthat"))
library(RRasdaman)
library(devtools)
library(RRasdaman)
library(RRasdaman)
library(RRasdaman)
library(RRasdaman)
library(mAr)
citation(mAr)
citation('mAr')
source("/home/atorres/EmiStatR/EmiStatR_120_4/R")
prompt("Delay")
getwd()
library(EmiStatR)
data(P1)
P1_delayed5 <- (P1, 5)
P1_delayed5 <- Delay(P1, 5)
wdir <-  "/home/atorres//Documents/02_working/3-Production/05_IV-Year/05_models/01_stUPscales"
commit.label <- 'initial_commit'
username   <- "ArturoTorres"
password   <- "sehajsamadhi1A"
repository <- "https://github.com/ERIN-LIST/stUPscales.git"
credential <- paste0("https://", username, ":", password, "@", repository)
setwd(wdir)
system("git status")
system("git log")
system("git add .")
system(paste0("git commit -a -m '", commit.label, "'"))
system("git status")
system("git log")
system(paste0("git config remote.origin.url ", credential))
system(paste0("git push ", credential, " master"))
plot(P1[,2])
plot(P1[,2], typ = "l")
plot(P1[,2], typ = "l", col = "blue")
lines(P1_delayed5[,2], col = "red")
P1_delayed15 <- Delay(P1, 15)
plot(P1[,2], typ = "l", col = "blue")
lines(P1_delayed15[,2], col = "red")
P1_delayed15 <- Delay(P1, 50)
plot(P1[,2], typ = "l", col = "blue")
lines(P1_delayed15[,2], col = "red")
head(P1_delayed15)
P1_delayed15 <- Delay(P1, 500)
head(P1_delayed15)
plot(P1[,2], typ = "l", col = "blue")
lines(P1_delayed15[,2], col = "red")
a <- P1[,2] - P1_delayed15[,2]
a
sum(a)
sum(P1[,2])
sum(P1_delayed15[,2])
P1_delayed15 <- Delay(P1, 500)
plot(P1_delayed15[,2], typ= "l", col = "red")
plot(P1[,2], typ = "l", col = "blue")
plot(P1_delayed15[,2], typ= "l", col = "red")
head(P1_delayed15)
P1_delayed15 <- Delay(P1 = P1, x = 500)
head(P1_delayed15)
plot(P1[,2], typ = "l", col = "blue")
plot(P1_delayed15[,2], typ= "l", col = "red")
library(EmiStatR)
data(P1)
P1_delayed15 <- Delay(P1 = P1, x = 500)
head(P1_delayed15)
plot(P1[,2], typ = "l", col = "blue")
plot(P1_delayed15[,2], typ= "l", col = "red")
a <- P1[,2] - P1_delayed15[,2]
sum(a)
P1_delayed <- Delay(P1 = P1, x = 500)
head(P1_delayed)
plot(P1[,2], typ = "l", col = "blue")
plot(P1_delayed[,2], typ= "l", col = "red")
lines(P1_delayed[,2], col = "red")
a <- P1[,2] - P1_delayed15[,2]
sum(P1[,2])
sum(P1_delayed15[,2])
sum(a)
